/*
 * Executable
 * Runs hacking scripts on available servers, as appropriate
 * Copied/modified from
 *     https://gist.github.com/jaguilar/a8f7cb8da78cbddc2a06415fdf97df27
 */

import {
    execa
    } from 'lib.execa.ns';
import {
    awaitSignal,
    consumeSignal
    } from 'lib.signal.ns'
import {
    getServerList,
    getMemoryTotal,
    getServerSize,
    getHostname,
    getMemoryAvailable,
    useMemory
    } from 'lib.servers.ns';

const SCRIPT_WATCH_SECURITY = "exec.watch-security.ns";
const SCRIPT_WATCH_HACKABLE = "exec.watch-hackable.ns";
const SCRIPT_FLEXIHACK = "exec.flexihack.ns";
const SCRIPT_WEAKEN = "exec.weaken.ns";

const SCRIPTS_TO_COPY = [
    SCRIPT_FLEXIHACK,
    SCRIPT_WEAKEN,
    'lib.servers.ns'
];
const TAG_HACKING = "hacking";
const TAG_WEAKENING = "weakening";

// 10% of the home server's memory, with a minimum of 100g, is reserved to not be used by this script
const HOME_RESERVED_MEMORY = 100;
const HOME_RESERVED_FRACTION = 0.10;

async function resetScripts(ns, server) {
    SCRIPTS_TO_COPY.forEach((scriptName) => {
        if (!ns.fileExists(scriptName, 'home')) {
            ns.tprint("Script not found: " + scriptName);
        }
    });

    const hostname = getHostname(server);
    while (ns.scriptKill(SCRIPT_FLEXIHACK, hostname)) {
        await ns.sleep(100);
    }
    while (ns.scriptKill(SCRIPT_WEAKEN, hostname)) {
        await ns.sleep(100);
    }
    if (hostname !== "home") {
        do {
            ns.killall(hostname);
        } while (ns.getServerRam(hostname)[1] > 0);
        ns.scp(SCRIPTS_TO_COPY, "home", hostname);
    }
}


/*
 * Pretty much the same as servers.getMemoryAvailable, but reserves some amount to not being
 * used on [home]
 */
function getMemoryUsable(ns, server) {
    let memory = getMemoryAvailable(ns, server);
    if (getHostname(server) === 'home') {
        let totalMemory = getMemoryTotal(ns, server);
        let reserved = Math.max(HOME_RESERVED_MEMORY, HOME_RESERVED_FRACTION * totalMemory);
        memory -= reserved;
    }

    return memory;
}

/*
 * Runs [numberToRun] threads of [jobScript] on [servers] targeting [targetHostname]
 *
 * Tag is an unused argument to differentiate different instances of the same script.
 */
function scheduleOn(ns, attackServers, jobScript, numberToRun, targetHostname, tag) {
    //ns.tprint("scheduleOn: [" + jobScript + "] targeting [" + targetHostname + "] on " + attackServers.length + " servers");

    // Script should have been copied out to all candidate hosts already.
    let ramPerTask = ns.getScriptRam(jobScript, "home");

    while (numberToRun > 0 && attackServers.length > 0) {
        const server = attackServers[0];
        const attackerHostname = getHostname(server);
        const memoryAvailable = getMemoryUsable(ns, server);
        //ns.tprint("Memory available on [" + attackerHostname + "]: " + memoryAvailable);

        // Schedule as many threads of the task as possible on the first host.
        const threadsOnThisHost = Math.min(Math.floor(memoryAvailable / ramPerTask), numberToRun);
        ns.print("Threads to run on [" + attackerHostname + "]: " + threadsOnThisHost + " threads "
            + "(" + memoryAvailable + " memory available, " + ramPerTask + " per task");

        numberToRun -= threadsOnThisHost;
        if (threadsOnThisHost > 0) {
            let argList = [jobScript, attackerHostname, threadsOnThisHost, targetHostname, tag];
            ns.tprint("execute: " + argList);
            if (execa(ns, argList)) {
                useMemory(ns, server, (threadsOnThisHost * ramPerTask));
            } else {
                ns.tprint("Unable to run: " + JSON.stringify(argList));
                exit();
            }
        }

        // If we still have tasks left, that means we exhausted the RAM of this host.
        if (numberToRun > 0) {
            ns.print("consumed all ram available on " + attackerHostname);
            attackServers.shift();
        }
    }

    return attackServers;
}

// targets is an array of target machines to weaken and/or hack.
// servers is a list of server objects (see lib.servers.ns)
async function doHacks(ns, targetServers, attackServers) {
    // Iterate over the targets, which should be in order of easiest to hardest.
    // We're going to spend as many threads as possible to weaken each target to
    // get it to its weakest level as fast as possible.

    // We spawn at least a few flexihacks on each server so handled to make early
    // cashflow less painful, although things only really get hopping once we
    // have weakened the biggest server we can hack. At that point, we dedicate
    // all excess capacity to hacking said server, which gets lucrative fast.
    let weakenTargets = targetServers.slice(0, targetServers.length);
    let loop = 0;
    while (weakenTargets.length > 0 && attackServers.length > 0) {
        const target = weakenTargets.shift();
        const targetHostname = getHostname(target);

        // ns.tprint("weakenloop: " + targetHostname);

        let minSecurityLevel = ns.getServerMinSecurityLevel(targetHostname); // convert this to servers function
        if (ns.getServerSecurityLevel(targetHostname) <= (3 + minSecurityLevel)) {
            //ns.tprint("already weakened: " + targetHostname);
            // Just spawn one weaken and a round of flexihacks. This is to make early game cashflow less painful.
            attackServers = scheduleOn(ns, attackServers, SCRIPT_WEAKEN, 1, targetHostname, TAG_WEAKENING + "/" + loop);
            attackServers = scheduleOn(ns, attackServers, SCRIPT_FLEXIHACK, 6, targetHostname, TAG_WEAKENING + "/" + loop);
        } else {
            // Spawn only weakens until security is near minimum.
            let numberOfWeakens = Math.floor((ns.getServerSecurityLevel(targetHostname) - ns.getServerMinSecurityLevel(targetHostname)) / 0.05);
            //ns.tprint("needs " + numberOfWeakens + " weaken threads");
            attackServers = scheduleOn(ns, attackServers, SCRIPT_WEAKEN, numberOfWeakens, targetHostname, TAG_WEAKENING + "/" + loop);
            watchSecurity(ns, targetHostname, minSecurityLevel);
        }

        loop += 1;
        await ns.sleep(10); // to give the ui a chance to update
    }

    ns.print("Hacks Run - Target Servers Left: " + weakenTargets.map((server) => getHostname(server)).join(", "));
    ns.print("Hacks Run - Attack Servers Left: " + attackServers.map((server) => getHostname(server)).join(", "));

    // If there are any resources left, it's time to hack! We will schedule up to ~100
    // hack workers targetting a given server. Generally speaking we want to target
    // servers that are deeper in the search tree. These will tend to appear at the end
    // of the target list.
    while (targetServers.length > 0 && attackServers.length > 0) {
        let target = targetServers.pop();
        let targetHostname = getHostname(target);
        ns.print("flexihack loop " + targetHostname + " with " + attackServers.length + " attack servers");

        // We stagger the scheduling of flexihacks so that not all hundred threads
        // are hacking or growing at the same time. We believe this will reduce waste.
        // We are also staggering the scheduling of weakens, which seems like a waste.
        // We can probably make a reasonable guess as to how many will actually be used.
        //
        // Rule of thumb: one weaken per six flexihacks. Derivation: hack takes
        // 0.002 security, grow takes 2.5x as long at takes 0.005. Weaken takes ~3.5x
        // and 0.05. Divide the rates through and it seems like no matter whether you're
        // doing grow or hack, you're using about 1/6th as much security per unit time (
        // not accounting for failed hacks).
        // for (let i = 0; attackServers.length > 0 && i < 15; ++i) { // TODO: why 15?

        const scriptSizeWeaken = ns.getScriptRam(SCRIPT_WEAKEN, "home");
        const scriptSizeFlexi = ns.getScriptRam(SCRIPT_FLEXIHACK, "home");

        let rounds = 0;
        for (; attackServers.length > 0 && rounds < 150; rounds++) { // Should never go over 150, but lets play it safe
            // Determine the total amount of threads available across all server
            // Then use half of them, down to a minimum of 1 and 6
            // Should make this a maximum of log2(threads) loops
            const totalThreads = attackServers
                .map((server) => getMemoryUsable(ns, server))
                .map((availableMemory) => Math.floor(availableMemory / (scriptSizeFlexi + scriptSizeWeaken)))
                .reduce((accumulator, currentValue) => accumulator + currentValue);

            ns.print("scheduling flexihack round " + rounds + " with " + totalThreads + " total threads");
            const weakenThreads = Math.max(1, Math.floor((totalThreads / 7.0) * 1));
            const flexiThreads = Math.max(6, Math.floor((totalThreads / 7.0) * 6));
            // Add the "rounds" to the tag so that the system considers them "different" scripts
            attackServers = scheduleOn(ns, attackServers, SCRIPT_WEAKEN, weakenThreads, targetHostname, TAG_HACKING + "/" + rounds);
            attackServers = scheduleOn(ns, attackServers, SCRIPT_FLEXIHACK, flexiThreads, targetHostname, TAG_HACKING + "/" + rounds);

            await ns.sleep(10); // to give the ui a chance to update
        }
        ns.print("scheduled flexihack rounds total " + rounds);
    }
}

function getTargetServers(ns) {
    const servers = getServerList(ns);
    const purchasedServers = ns.getPurchasedServers();
    return servers.filter((server) => !purchasedServers.includes(getHostname(server)));
}

/**
 * Kills all the watch scripts (that this script would have started) running on the home server
 */
function killWatchScripts(ns) {
    const processes = ns.ps('home');

    processes
        .filter((process) => process.filename === SCRIPT_WATCH_SECURITY || process.filename === SCRIPT_WATCH_HACKABLE)
        .forEach((process) => {
            //ns.tprint("Killing script: " + JSON.stringify(process));
            ns.kill(process.pid);
        });
}

/**
 * Watch for the security level on this host to get low, and signal ourselves when it does.
 * We assume that we are able to afford to run one of these on the local server.
 * If not, we are probably under-buying local ram.
 */
function watchSecurity(ns, targetHostname, minSecurityLevel) {
    if (!ns.run(SCRIPT_WATCH_SECURITY, 1, targetHostname, (3 + minSecurityLevel))) {
        ns.tprint("Unable to run [" + SCRIPT_WATCH_SECURITY + "] on [" + targetHostname + "]");
    }
}

/**
 * Given a list of servers, setup a script that will signal ourselves when our current
 * is high enough to hack one of them AND we have root on it
 */
function watchHackable(ns, servers) {
    const hostnames = servers.map((server) => getHostname(server));
    if (!ns.run(SCRIPT_WATCH_HACKABLE, 1, JSON.stringify(hostnames))) {
        ns.tprint("Unable to run [" + SCRIPT_WATCH_HACKABLE + "] on [" + targetHostname + "]");
    }
}

export async function main(ns) {
    consumeSignal(ns);

    while (true) {
        const servers = getServerList(ns);
        const purchasedServers = ns.getPurchasedServers();
        const hackingLevel = ns.getHackingLevel();

        // Generate the list of servers we want to target with hacks

        const possibleTargetServers = servers
            .filter((server) => !purchasedServers.includes(getHostname(server)))
            .filter((server) => !["darkweb", "home"].includes(getHostname(server)));

        const currentlyHackable = possibleTargetServers
            .filter((server) => ns.hasRootAccess(getHostname(server)) === true)
            .filter((server) => ns.getServerRequiredHackingLevel(getHostname(server)) <= hackingLevel);
        const eventuallyHackable = possibleTargetServers
            .filter((server) => !currentlyHackable.includes(server));

        // ns.tprint("Currently hackable: " + currentlyHackable.map((s) => getHostname(s)).join(", "));
        // ns.tprint("");
        //ns.tprint("Eventually hackable: " + eventuallyHackable.map((s) => getHostname(s)).join(", "));

        // TODO: Add [getServerRequiredHackingLevel] to server functions

        ns.print("Target Servers = " + currentlyHackable.map((server) => getHostname(server)).join(", "));

        // Generate the list of servers that we will run the hacks from
        // TODO: Figure out how to add home later
        let attackServers = servers
            .filter((server) => ns.hasRootAccess(getHostname(server)))
            .filter((server) => !["darkweb" /*, "home" */].includes(getHostname(server)));
        ns.print("Attack Servers = " + attackServers.map((server) => getHostname(server)).join(", "));

        ns.tprint("Identified Servers: " + currentlyHackable.length + " targets, " + attackServers.length + " attackers");
        // Cancel all running weakens and flexihacks on hosts, and record
        // their available RAM.
        for (let i=0; i<servers.length; i++) {
            await resetScripts(ns, servers[i]);
        }

        await ns.sleep(100);

        killWatchScripts(ns);
        await ns.sleep(100);

        watchHackable(ns, eventuallyHackable);

        await doHacks(ns, currentlyHackable, attackServers);

        // At the end of the loop, we wait for a signal that something has changed.
        // This entails seeing any value in the signalPort.
        await awaitSignal(ns);
        ns.tprint("notified! restarting everything");
    }
}
