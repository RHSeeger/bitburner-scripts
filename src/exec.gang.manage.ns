/*
 * Executable: exec.gang.manage.ns
 *
 * From: https://github.com/Penndrageist/bitburner-scripts/blob/master/scripts/gangManager.js.js
 */

function getRandomInt(max) {
    return Math.floor(Math.random() * Math.floor(max));
}

// 30 possible gang members
// create list of names
let memberNamePool = [
    "Thor",           // 1
    "Iron Man",       // 2
    "Starlord",       // 3
    "Thanos",         // 4
    "Groot",          // 5
    "Ant-Man",        // 6
    "Wasp",           // 7
    "Spiderman",      // 8
    "Loki",           // 9
    "Gamora",         // 10
    "Rocket Raccoon", // 11
    "T'Challa",       // 12
    "Vision",         // 13
    "Scarlet Witch",  // 14
    "Winter Soldier", // 15
    "Black Widow",    // 16
    "Hulk",           // 17
    "Bruce Banner",   // 18
    "Hawkeye",        // 19
    "Captain Marvel", // 20
    "War Machine",    // 21
    "Nick Fury",      // 22
    "Nebula",         // 23
    "Drax",           // 24
    "Deadpool",       // 25
    "Cable",          // 26
    "Quicksilver",    // 27
    "Wolverine",      // 28
    "Adam Warlock",   // 29
    "Yondu",          // 30
];

// TODO: Replace these with FLAG_* to make it clearer in the code
const FLAGS = [
    ['focused', false],
    ['buyAll', false],
    ['buyEquip', false],
    ['buyWeapon', false],
    ['buyArmor', false],
    ['buyVehicle', false],
    ['buyRoot', false],
    ['buyAug', false],
    ['buyBat', true],
    ['c', 0.6], // Minimum acceptable combat win level
    ['asc', 600000] // Ascension cycles
];

const ASCEND_CYCLES = 1000; // The number of times to ascend a gang member each time we ascend
const ASCENSION_MULTIPLIER_LIMIT = 25; // ascension multiplier limit (beyond which we won't ascend)

const TASK_UNASSIGNED = 'Unassigned';
const TASK_MUG = 'Mug People';
const TASK_DEAL_DRUGS = 'Deal Drugs';
const TASK_STRONGARM = 'Strongarm Civilians';
const TASK_RUN_CON = 'Run a Con';
const TASK_ARMED_ROBBERY = 'Armed Robbery';
const TASK_TRAFFICK_ARMS = 'Traffick Illegal Arms';
const TASK_BLACKMAIL = 'Threaten & Blackmail';
const TASK_TRAFFICK_HUMANS = 'Human Trafficking';
const TASK_TERRORISM = 'Terrorism';
const TASK_VIGILANTE = 'Vigilante Justice';
const TASK_TRAIN_COMBAT = 'Train Combat';
const TASK_TRAIN_HACKING = 'Train Hacking';
const TASK_TRAIN_CHARISMA = 'Train Charisma';
const TASK_TERRITORY_WARFARE = 'Territory Warfare';
const TASK_RANSOMWARE = "Ransomware";
const TASK_PHISHING = "Phishing";
const TASK_IDENTITY_THEFT = "Identity Theft";
const TASK_DDOS = "DDoS Attacks";
const TASK_VIRUS = "Plant Virus";
const TASK_FRAUD = "Fraud & Counterfeiting";
const TASK_MONEY_LAUNDER = "Money Laundering";
const TASK_CYBERTERRORISM = "Cyberterrorism";
const TASK_ETHICAL_HACKING = "Ethical Hacking";

const TASKS_COMBAT = [
    TASK_MUG, TASK_DEAL_DRUGS, TASK_STRONGARM, TASK_RUN_CON, TASK_ARMED_ROBBERY,
    TASK_TRAFFICK_ARMS, TASK_BLACKMAIL, TASK_TRAFFICK_HUMANS, TASK_TERRORISM,
    TASK_VIGILANTE
];
const TASKS_HACKING = [
    TASK_RANSOMWARE, TASK_PHISHING, TASK_IDENTITY_THEFT, TASK_DDOS, TASK_VIRUS,
    TASK_FRAUD, TASK_MONEY_LAUNDER, TASK_CYBERTERRORISM,
    TASK_ETHICAL_HACKING
];
const ALL_TASKS = [
    TASK_UNASSIGNED,
    ...TASKS_COMBAT,
    ...TASKS_HACKING,
    TASK_TRAIN_COMBAT, TASK_TRAIN_HACKING, TASK_TRAIN_CHARISMA,
    TASK_TERRITORY_WARFARE
];
const TERRITORY_TASKED_PERCENT = 25;

/*
 * Returns the best member to ascend at this time, the one with lowest multipliers
 * If all members are above the limit to ascend, returns null
 */
function determineBestMemberToAscend(ns) {
    const members = ns.gang.getMemberNames();
    const sortedValidMembers = members
        .map(member => ns.gang.getMemberInformation(member))
        .filter(memberInfo => memberInfo.str_asc_mult < ASCENSION_MULTIPLIER_LIMIT)
        .sort((a, b) => a.str_asc_mult - b.str_asc_mult) // We only care about Strength because we're using the bat to ascend
        .map(memberInfo => memberInfo.name);

    if (sortedValidMembers.length <= 0) {
        return null;
    }

    return sortedValidMembers[0];
}

// TODO: Handle hacking gangs stat limit too
async function ascendMember(ns, memberName) {
    let i;
    for (i = 0; i < ASCEND_CYCLES; i++) {
        const memberInfo = ns.gang.getMemberInformation(memberName);
        if (memberInfo.str_asc_mult >= ASCENSION_MULTIPLIER_LIMIT) {
            ns.print("Member [" + memberName + "] has surpassed multiplier limits (after " + i + " ascensions)")
            return;
        }
        if (!memberInfo.upgrades.includes('Baseball Bat')) {
            ns.gang.purchaseEquipment(memberName, 'Baseball Bat');
        }
        ns.gang.ascendMember(memberName);
        if (i % 100 === 0) {
            ns.sleep(1);
        }
    }

    ns.print("Ascended [" + memberName + "] " + i + " times");
}

function buyEquipment(ns, member, buyableEquipment) {
    // TODO: figure this out later... we don't want to buy equipment unless the char is already maxed out
    return;
    let didBuy = false;

    const memInfo = ns.gang.getMemberInformation(member);

    //ns.gang.setMemberTask(m, TASK_UNASSIGNED);

    buyableEquipment.forEach((equipment) => {
        if (memInfo.upgrades.includes(equipment)) {
            return;
        }
        if (memInfo.augmentations.includes(equipment)) {
            return;
        }

        var type = ns.gang.getEquipmentType(equipment);
        switch (type) {
            case "Weapon":
                if (buyWeapon) {
                    didBuy |= ns.gang.purchaseEquipment(member, equipment);
                }
                break;
            case "Armor":
                if (buyArmor) {
                    didBuy |= ns.gang.purchaseEquipment(member, equipment);
                }
                break;
            case "Vehicle":
                if (buyVehicle) {
                    didBuy |= ns.gang.purchaseEquipment(member, equipment);
                }
                break;
            case "Rootkit":
                if (buyRoot) {
                    didBuy |= ns.gang.purchaseEquipment(member, equipment);
                }
                break;
            case "Augmentation":
                if (buyAug) {
                    didBuy |= ns.gang.purchaseEquipment(member, equipment);
                }
                break;
            default:
                break;
        }
    });

    return didBuy;
}


export async function main(ns) {
    ns.disableLog('ALL');

    var flagValues = ns.flags(FLAGS);

    var balanceTasks = !flagValues['focused'];
    var minCombatWinLevel = Math.min(flagValues['c'], 1.0);

    var buyAll = flagValues['buyAll'];

    var buyEquip = buyAll || flagValues["buyEquip"];

    var buyWeapon = buyAll || buyEquip || flagValues["buyWeapon"];
    var buyArmor = buyAll || buyEquip || flagValues["buyArmor"];
    var buyVehicle = buyAll || buyEquip || flagValues["buyVehicle"];
    var buyRoot = buyAll || buyEquip || flagValues["buyRoot"];

    var buyAug = buyAll || flagValues["buyAug"];

    var myGang = ns.gang.getGangInformation();

    // Confirm that all the tasks we think we know... exist
    var possibleTasks = ns.gang.getTaskNames();
    ns.print(`All Tasks: ${possibleTasks}`);
    const invalidTasks = ALL_TASKS
        .filter(task => !(myGang.isHacking ? TASKS_COMBAT : TASKS_HACKING).includes(task))
        .filter(task => !possibleTasks.includes(task));
    if (invalidTasks.length > 0) {
        ns.tprint("The following tasks were not recognized: " + invalidTasks.join(", "));
        return;
    }

    var territoryTask = TASK_TERRITORY_WARFARE;
    let trainingTasks = [ TASK_TRAIN_COMBAT, TASK_TRAIN_HACKING, TASK_TRAIN_CHARISMA ];
    var wantedLevelLowerTask = TASK_VIGILANTE;

    var desirableAugs = [];

    if(myGang.isHacking) {
        wantedLevelLowerTask = TASK_ETHICAL_HACKING;

        trainingTasks = [ TASK_TRAIN_HACKING, TASK_TRAIN_CHARISMA ];

        desirableAugs.push("BitWire");
        desirableAugs.push("Neuralstimulator");
        desirableAugs.push("DataJack");
    } else {
        wantedLevelLowerTask = TASK_VIGILANTE;

        trainingTasks = [ TASK_TRAIN_COMBAT, TASK_TRAIN_CHARISMA ];

        desirableAugs.push("Bionic Arms");
        desirableAugs.push("Bionic Legs");
        desirableAugs.push("Bionic Spine");
        desirableAugs.push("BrachiBlades");
        desirableAugs.push("Nanofiber Weave");
        desirableAugs.push("Synthetic Heart");
        desirableAugs.push("Synfibril Muscle");
        desirableAugs.push("Graphene Bone Lacings");
    }


    var ascensionCycles = flagValues["asc"];
    var nextAscensionAttempt = 0;
    var cycleMs = 2100;
    //var ascensionMultLimit = flagValues["alim"];

    ns.print(`unassignedTask: ${TASK_UNASSIGNED}`);
    ns.print(`territoryTask: ${territoryTask}`);
    ns.print(`trainingTasks: ${trainingTasks}`);
    ns.print(`possibleTasks: ${possibleTasks}`);
    ns.print(`wantedLevelLowerTask: ${wantedLevelLowerTask}`);

    await ns.sleep(1000);

    var otherGangs = ns.gang.getOtherGangInformation();
    var otherGangNames = [];
    for(var gangName in otherGangs) {
        otherGangNames.push(gangName);
        //ns.tprint(gangName);
    }

    while (true) {
        myGang = ns.gang.getGangInformation();
        var otherGangs = ns.gang.getOtherGangInformation();
        var buyableEquipment = ns.gang.getEquipmentNames().filter(e => {
            return ns.gang.getEquipmentType(e) != "Augmentation" || desirableAugs.includes(e);
        });

        // -- Setup gang warfare --
        if(myGang.isHacking) {
            ns.gang.setTerritoryWarfare(false);
        } else {
            ns.gang.setTerritoryWarfare(otherGangNames.every(name => ns.gang.getChanceToWinClash(name) > minCombatWinLevel));
        }

        var members = ns.gang.getMemberNames();

        // -- Recruit new members if we can --
        while(ns.gang.canRecruitMember()) {
            var possibleNames = memberNamePool.filter(name => !members.includes(name));
            var toRecruit = possibleNames[getRandomInt(possibleNames.length)];

            ns.gang.recruitMember(toRecruit);
            await ns.sleep(1);
        }

        // -- Handle ascensions --
        const batCost = ns.gang.getEquipmentCost('Baseball Bat');
        if (!batCost) {
            ns.tprint("Unable to determine cost of bat");
            ns.exit();
        }
        if (ns.getServerMoneyAvailable("home") > ((batCost * ASCEND_CYCLES) * 2)) {
            const memberToAscend = determineBestMemberToAscend(ns);
            if (memberToAscend != null) {
                ns.print("Found best member to ascend: " + memberToAscend);
                await ascendMember(ns, memberToAscend);
            }
        }

        // -- Buy Gear --
        members = ns.gang.getMemberNames();
        members.sort((a,b)=> { return Math.random()*2-1; } );
        members.forEach(member => buyEquipment(ns, member, buyableEquipment));

        // -- Assign Tasks --
        let numTerritoryTasked = 0;
        const totalMembers = members.length;
        const desiredTerritoryWorkers = myGang.isHacking
            ? 0
            : Math.floor(totalMembers * TERRITORY_TASKED_PERCENT / 100);

        while (members.length > 0) {
            var task = "";
            const member = members.pop();
            const memInfo = ns.gang.getMemberInformation(member);

            let statsTarget = 50;

            myGang = ns.gang.getGangInformation();

            let reduceWanted = myGang.wantedLevel > 1;
            if(balanceTasks) {
                reduceWanted |= myGang.wantedLevelGainRate > 0;
            }

            if((myGang.isHacking && memInfo.hacking < statsTarget) ||
                (!myGang.isHacking && memInfo.strength < statsTarget && memInfo.agility < statsTarget && memInfo.charisma < statsTarget && memInfo.defense < statsTarget)) {
                // TRAINING
                task = trainingTasks[getRandomInt(trainingTasks.length)];
            } else if (numTerritoryTasked < desiredTerritoryWorkers) {
                // TERRITORY
                task = TASK_TERRITORY_WARFARE;
              numTerritoryTasked += 1;
            } else if (reduceWanted) {
                // WANTED
                task = wantedLevelLowerTask;
            } else {
                // OTHER
                // TODO: This should really be based on what they can do well based on stats
                task = possibleTasks[getRandomInt(possibleTasks.length) - 1];
            }

            ns.gang.setMemberTask(member, task);
        }

        await ns.sleep(cycleMs);
        nextAscensionAttempt -= cycleMs;
    }
}
